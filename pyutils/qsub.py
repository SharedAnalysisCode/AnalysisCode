#!/usr/bin/env python
"""
qsub.py

A python module for submitting qsub jobs.  The user should use
the run function defined below.
"""

## std
import time
import os
import sys
import optparse
from glob import glob

## pyutils
import listutils
import pflock


path_of_this_file = os.path.abspath( __file__ )
dir_of_this_file = os.path.dirname( path_of_this_file )


#------------------------------------------------------------------------------
class Pool(object):

    #__________________________________________________________________________
    def __init__(self, n, **kw):
        self._n = n
        self._config = dict(kw)
        self._config.setdefault('setup', '/bin/echo "no setup"')
        self._config.setdefault('executable', '/bin/echo')

    #__________________________________________________________________________
    def write_job_config(self, args, filename):

        tmp = dict(self._config)
        tmp['time'] = time.ctime()
        tmp['user'] = os.environ['USER']
        tmp['arguments'] = args
        tmp['filename'] = filename
        template = """# qsub config file
#
# %(filename)s
# %(time)s
# user: %(user)s
# generated by pyutils/qsub.py
# see also: https://asrv-02.hep.upenn.edu/groups/pennatlastier3users://wikis.nyu.edu/display/NYUHPC/Tutorial+-+Submitting+a+job+using+qsub 
#------------------------------------------------------------------------------

cd ${PBS_O_WORKDIR}
#source /group/atlas/prj/leister/zpcode/PennTau-ZprimeTauTauLepHad2012-00-00-00/setup.sh -r
%(setup)s
#python /group/atlas/prj/leister/zpcode/PennTau-ZprimeTauTauLepHad2012-00-00-00/ZprimeTauTauLepHad2012/run/helloworld.py
%(executable)s %(arguments)s

#------------------------------------------------------------------------------
# EOF
"""
        f = open(filename, 'w')
        f.write(template % tmp)
        f.close()

    #__________________________________________________________________________
    def map(self, args, dirname='test'):
        assert len(args) == self._n, 'len(args) = %s,  self._n = %s' % (len(args), self._n)
        basedir = os.getcwd()
        for i, a in enumerate(args):
            initialdir = os.path.join(basedir, dirname, 'job_%03i' % i)
            print 'initialdir = %s' % initialdir
            if not os.path.isdir(initialdir):
                print 'mkdir -p %s' % initialdir
                os.system('mkdir -p %s' % initialdir)
            filename = 'qsub_job.sh'
            fullpath = os.path.join(initialdir, filename)
            self.write_job_config(a, fullpath)
            os.chdir(initialdir)
            cmd = 'qsub -q hep -l mem=8gb,naccesspolicy=shared %s' % filename
            print cmd
            os.system(cmd)
            time.sleep(2)
        os.chdir(basedir)

# end of Pool class definition


#------------------------------------------------------------------------------
# free functions
#------------------------------------------------------------------------------

#______________________________________________________________________________
def run(exe, arg_template, input, dirname='qsub_test', n_files=0, n_jobs=0,
       comma_sep_input=False, setup=None):
    """
    exe: The name of the executable to be run.  Probably best to give
         the full path like '/home/user/my_job'
    arg_template: Should be the arguments given after the executable
         with a %s in place of where the input files will be given
         as a comma-separated list.
    input: a list of the input files to be divided among jobs.
    dirname: the name of the working directory for the qsub job to
         create and run in.
    n_files: the number of files per sub-job.
    n_jobs: the number of sub-jobs.
    """

    # glob paths
    input_files = []
    for fn in input:
        if fn.count('*'):
            input_files.extend( glob(fn) )
        else:
            input_files.append(fn)

    # divide input files
    if n_files:
        divided_files = [ x for x in listutils.chunk(input_files, n_files) ]
    elif n_jobs:
        divided_files = [ x for x in listutils.divide(input_files, n_jobs) ]
    else:
        divided_files = [ x for x in listutils.chunk(input_files, 1) ]

    divided_files = filter(None, divided_files)
    if n_jobs and n_jobs != len(divided_files):
        print '  There are only %s files for %s jobs.' % (len(divided_files), n_jobs)
        print '  Changing n_jobs = %s jobs.' % (len(divided_files))

    # make args list
    if comma_sep_input:
        args = [ arg_template % (','.join(files)) for files in divided_files ]
    else:
        args = [ arg_template % (' '.join(files)) for files in divided_files ]

    # run
    if setup:
        pool = Pool(len(args), executable=exe, setup=setup)
    else:
        pool = Pool(len(args), executable=exe, setup=None)
    return pool.map(args, dirname=dirname)


